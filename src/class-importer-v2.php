<?php

namespace WP_Parser;

use Psr\Log\LoggerInterface;
use WP_Error;
use WP_Parser\Importers\FileImporter;
use WP_Parser\Importers\ImportLogger;
use wpdb;

/**
 * Handles creating and updating posts from (functions|classes|files) generated by phpDoc.
 */
class ImporterV2 {

	/**
	 * @var string
	 */
	public static $taxonomy_file = 'wp-parser-source-file';

	/**
	 * @var string
	 */
	public static $taxonomy_namespace = 'wp-parser-namespace';

	/**
	 * @var string
	 */
	public static $taxonomy_since_version = 'wp-parser-since';

	/**
	 * @var string
	 */
	public static $taxonomy_package = 'wp-parser-package';

	/**
	 * @var string
	 */
	public static $taxonomy_plugin = 'wp-parser-plugin';

	/**
	 * @var string
	 */
	public static $post_type_function = 'wp-parser-function';

	/**
	 * @var string
	 */
	public static $post_type_class = 'wp-parser-class';

	/**
	 * @var string
	 */
	public static $post_type_method = 'wp-parser-method';

	/**
	 * @var string
	 */
	public static $post_type_hook = 'wp-parser-hook';




	/**
	 * Handy store for meta about the current item being imported
	 *
	 * @var array
	 */
	public $file_meta = [];

	/**
	 * @var array Cached items of inserted terms
	 */
	protected $inserted_terms = [];

	/**
	 * @var string
	 */
	protected $plugin_name = '';

	/**
	 * @var string
	 */
	protected $plugin_dir = '';

	/**
	 * @var LoggerInterface
	 */
	private $logger;

	/**
	 * @var array|WP_Error
	 */
	private static $plugin_term;

	/**
	 * Constructor. Sets up post type/taxonomy names.
	 */
	public function __construct( LoggerInterface $logger ) {
		$this->logger = $logger;
	}

	public function import( array $files, bool $import_ignored = false ) {
		$time_start = microtime( true );

		$this->logger->info( 'Starting import. This will take some time...' );
		$this->disable_caching();
		$this->disable_transisiton_actions();

		if ( ! $this->necessary_post_types_exist() ) {
			$this->logger->error( sprintf(
				'Missing post type; check that "%1$s", "%2$s", and "%3$s" are registered.',
				self::$post_type_class,
				self::$post_type_function,
				self::$post_type_hook
			) );

			exit;
		}

		if ( ! $this->necessary_taxonomies_exist() ) {
			$this->logger->error( sprintf(
				'Missing taxonomy; check that "%1$s" is registered.',
				self::$taxonomy_file
			) );

			exit;
		}

		$imported_files = new FileImporter( $files, $import_ignored, $this->logger );

		$this->log_last_import();

		/**
		 * Action at the end of a complete import
		 */
		do_action( 'wp_parser_ending_import' );

		$this->enable_caching();

		$time_end = microtime( true );
		$time = $time_end - $time_start;
		$this->logger->info( 'Time: ' . $time );

		if ( ! $this->logger->has_stashed_errors() ) {
			$this->logger->info( 'Import complete!' );
		} else {
			$this->logger->info( 'Import complete, but some errors were found:' );
			$this->logger->output_stashed_errors();
		}
	}

	public static function get_plugin_term() {
		return self::$plugin_term;
	}

	public static function set_plugin_term( string $plugin_term ) {
		self::$plugin_term = $plugin_term;
	}

	protected function get_plugin_from_file( array $file ) {
		if ( ! isset( $file['plugin'] ) ) {
			return;
		}

		$plugin_term = $this->insert_term( $file['plugin'], self::$taxonomy_plugin );

		add_term_meta( $plugin_term['term_id'], '_wp-parser-plugin-directory', plugin_basename( $file['root'] ), true );

		if ( ! isset( self::$plugin_name ) || self::$plugin_name !== $file['plugin'] ) {
			self::$plugin_name = $file['plugin'];
		}

		self::set_plugin_term( $plugin_term );
	}

	private function disable_caching(  ) {
		wp_suspend_cache_invalidation( true );
		wp_defer_comment_counting( true );
		wp_defer_term_counting( true );
	}

	private function enable_caching() {
		wp_suspend_cache_invalidation( false );
		wp_defer_comment_counting( false );
		wp_defer_term_counting( false );

		$this->flush_caches();
	}

	private function flush_caches() {
		/**
		 * Workaround for a WP core bug where hierarchical taxonomy caches are not being cleared
		 *
		 * https://core.trac.wordpress.org/ticket/14485
		 * http://wordpress.stackexchange.com/questions/8357/inserting-terms-in-an-hierarchical-taxonomy
		 */
		delete_option( sprintf( "%s_children", self::$taxonomy_package ) );
		delete_option( sprintf( "%s_children", self::$taxonomy_since_version ) );

		wp_cache_flush();
	}

	private function disable_transisiton_actions() {
		remove_action( 'transition_post_status', '_update_blog_date_on_post_publish', 10 );
		remove_action( 'transition_post_status', '__clear_multi_author_cache', 10 );
	}

	private function set_import_root( string $root = '' ) {
		if ( empty( $root ) ) {
			return;
		}

		update_option( 'wp_parser_root_import_dir', $root );
		$this->logger->info( 'Updated option wp_parser_root_import_dir: ' . $root );
	}

	/**
	 * Logs the last import.
	 *
	 * @return void
	 */
	private function log_last_import() {
		$last_import = time();
		$import_date = date_i18n( get_option('date_format'), $last_import );
		$import_time = date_i18n( get_option('time_format'), $last_import );

		update_option( 'wp_parser_last_import', $last_import );

		$this->logger->info(
			sprintf( 'Updated option wp_parser_last_import: %1$s at %2$s.', $import_date, $import_time )
		);
	}

	private function necessary_post_types_exist() {
		return (
			post_type_exists( self::$post_type_class ) &&
			post_type_exists( self::$post_type_function ) &&
			post_type_exists( self::$post_type_hook )
		);
	}

	private function necessary_taxonomies_exist() {
		return (
			taxonomy_exists( self::$taxonomy_file ) &&
			taxonomy_exists( self::$taxonomy_since_version ) &&
			taxonomy_exists( self::$taxonomy_package )
		);
	}
}
