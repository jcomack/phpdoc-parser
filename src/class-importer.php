<?php

namespace WP_Parser;

use Psr\Log\LoggerInterface;
use Tightenco\Collect\Support\Collection;
use WP_Error;
use WP_Parser\DocPart\DocClass;
use WP_Parser\DocPart\DocFile;
use WP_Parser\DocPart\DocFunction;
use WP_Parser\DocPart\DocHook;
use WP_Parser\DocPart\DocMethod;
use WP_Parser\DocPart\DocPart;
use WP_Parser\Importers\ImportLogger;
use wpdb;

/**
 * Handles creating and updating posts from (functions|classes|files) generated by phpDoc.
 */
class Importer {

	/**
	 * Taxonomy name for files
	 *
	 * @var string
	 */
	public $taxonomy_file;

	/**
	 * Taxonomy name for an item's namespace tags
	 *
	 * @var string
	 */
	public $taxonomy_namespace;

	/**
	 * Taxonomy name for an item's @since tag
	 *
	 * @var string
	 */
	public $taxonomy_since_version;

	/**
	 * Taxonomy name for an item's @package/@subpackage tags
	 *
	 * @var string
	 */
	public $taxonomy_package;

	/**
	 * Taxonomy name for an item's plugin tags
	 *
	 * @var string
	 */
	public $taxonomy_plugin;

	/**
	 * Post type name for functions
	 *
	 * @var string
	 */
	public $post_type_function;

	/**
	 * Post type name for classes
	 *
	 * @var string
	 */
	public $post_type_class;

	/**
	 * Post type name for methods
	 *
	 * @var string
	 */
	public $post_type_method;

	/**
	 * Post type name for hooks
	 *
	 * @var string
	 */
	public $post_type_hook;

	/**
	 * Handy store for meta about the current item being imported
	 *
	 * @var array
	 */
	public $file_meta = [];

	/**
	 * @var array Cached items of inserted terms
	 */
	protected $inserted_terms = [];

	/**
	 * @var string
	 */
	protected $plugin_name = '';

	/**
	 * @var string
	 */
	protected $plugin_dir = '';

	/**
	 * @var ImportLogger
	 */
	private $logger;
	/**
	 * @var array|WP_Error
	 */
	private $plugin_term;

	const INSERTED_ITEM_MESSAGE = 'Inserted %1$s "%2$s"';
	const UPDATED_ITEM_MESSAGE  = 'Updated %1$s "%2$s"';
	const IGNORED_ITEM_MESSAGE  = 'Skipped importing @ignore-d %1$s "%2$s"';
	const ERRORED_ITEM_MESSAGE  = 'Problem inserting/updating post for %1$s "%2$s"';


	/**
	 * Constructor. Sets up post type/taxonomy names.
	 *
	 * @param array $args Optional. Associative array; class property => value.
	 */
	public function __construct( array $args = [] ) {

		$properties = wp_parse_args(
			$args,
			[
				'post_type_class'        => 'wp-parser-class',
				'post_type_method'       => 'wp-parser-method',
				'post_type_function'     => 'wp-parser-function',
				'post_type_hook'         => 'wp-parser-hook',
				'taxonomy_file'          => 'wp-parser-source-file',
				'taxonomy_namespace'     => 'wp-parser-namespace',
				'taxonomy_package'       => 'wp-parser-package',
				'taxonomy_since_version' => 'wp-parser-since',
				'taxonomy_plugin' 		 => 'wp-parser-plugin',
			]
		);

		foreach ( $properties as $property_name => $value ) {
			$this->{$property_name} = $value;
		}

		$this->logger = new ImportLogger();
	}

	/**
	 * Sets the logger.
	 *
	 * @param LoggerInterface $logger The logger to set.
	 *
	 * @return void.
	 */
	public function setLogger( LoggerInterface $logger ) {
		$this->logger->setLogger( $logger );
	}

	/**
	 * Import the PHPDoc $data into WordPress posts and taxonomies
	 *
	 * @param Collection $files					  The files to import.
	 * @param bool  $import_ignored_functions Optional; defaults to false. If true, functions marked `@ignore` will be imported.
	 *
	 * @return void
	 */
	public function import( Collection $files, $import_ignored_functions = false ) {
		global $wpdb;

		$time_start = microtime(true);
		$num_queries = $wpdb->num_queries;

		$this->logger->info( 'Starting import. This will take some timeâ€¦' );

		$file_number  = 1;
		$totalFiles = $files->count();

		$this->setupImport();

		// Sanity check -- do the required post types exist?
		if ( ! post_type_exists( $this->post_type_class ) || ! post_type_exists( $this->post_type_function ) || ! post_type_exists( $this->post_type_hook ) ) {
			$this->logger->error( sprintf( 'Missing post type; check that "%1$s", "%2$s", and "%3$s" are registered.', $this->post_type_class, $this->post_type_function, $this->post_type_hook ) );
			exit;
		}

		// Sanity check -- do the required taxonomies exist?
		if ( ! taxonomy_exists( $this->taxonomy_file ) || ! taxonomy_exists( $this->taxonomy_since_version ) || ! taxonomy_exists( $this->taxonomy_package ) ) {
			$this->logger->error( sprintf( 'Missing taxonomy; check that "%1$s" is registered.', $this->taxonomy_file ) );
			exit;
		}

		$files->each(
			function( $file ) use ( &$file_number, $totalFiles, $import_ignored_functions ) {
			$this->logger->info(
				sprintf(
					'Processing file %1$s of %2$s "%3$s".',
					number_format_i18n( $file_number ),
					number_format_i18n( $totalFiles ),
					$file->relativePath
				)
			);

			$file_number++;

			$this->import_file( $file, $import_ignored_functions );
		} );

		$this->log_last_import();
		$this->teardownImport();

		$time_end = microtime( true );
		$time = $time_end - $time_start;

		$this->logger->info( 'Time: ' . $time );
		$this->logger->info( 'Queries: ' . ( $wpdb->num_queries - $num_queries ) );

		if ( ! $this->logger->has_stashed_errors() ) {
			$this->logger->info( 'Import complete!' );
		} else {
			$this->logger->info( 'Import complete, but some errors were found:' );
			$this->logger->output_stashed_errors();
		}
	}

	/**
	 * Logs the last import.
	 *
	 * @return void
	 */
	protected function log_last_import() {
		$last_import = time();
		$import_date = date_i18n( get_option('date_format'), $last_import );
		$import_time = date_i18n( get_option('time_format'), $last_import );

		update_option( 'wp_parser_last_import', $last_import );

		$this->logger->info(
			sprintf( 'Updated option wp_parser_last_import: %1$s at %2$s.', $import_date, $import_time )
		);
	}

	/**
	 * Inserts the term for the passed taxonomy.
	 *
	 * @param int|string $term		The term to insert.
	 * @param string     $taxonomy	The taxonomy to insert the term for.
	 * @param array      $args		Additional arguments.
	 *
	 * @return array|WP_Error Returns the inserted term or error if the insertion fails.
	 */
	protected function insert_term( $term, $taxonomy, $args = [] ) {
		$parent = isset( $args['parent'] ) ? $args['parent'] : 0;

		if ( isset( $this->inserted_terms[ $taxonomy ][ $term . $parent ] ) ) {
			return $this->inserted_terms[ $taxonomy ][ $term . $parent ];
		}

		if ( ! $inserted_term = term_exists( $term, $taxonomy, $parent ) ) {
			$inserted_term = wp_insert_term( $term, $taxonomy, $args );
		}

		if ( ! is_wp_error( $inserted_term ) ) {
			$this->inserted_terms[ $taxonomy ][ $term . $parent ] = $inserted_term;
		}

		return $inserted_term;
	}

	/**
	 * For a specific file, go through and import the file, functions, and classes.
	 *
	 * @param DocFile $file
	 * @param bool  $import_ignored Optional; defaults to false. If true, functions and classes marked `@ignore` will be imported.
	 *
	 * @return void
	 */
	public function import_file( DocFile $file, $import_ignored = false ) {
		$this->plugin_term = $this->insert_term( $file->getPluginName(), $this->taxonomy_plugin );

		add_term_meta( $this->plugin_term['term_id'], '_wp-parser-plugin-directory', plugin_basename( $file->getRoot() ), true );
		add_term_meta( $this->plugin_term['term_id'], '_wp-parser-plugin-version',  $file->getPluginVersion(), true );

		// The path to the file.
		$path = $file->getPath();

		if ( ! isset( $this->plugin_name ) || $this->plugin_name !== $file->getPluginName() ) {
			$this->plugin_name = $file->getPluginName();
		}

		// Maybe add this file to the file taxonomy
		$slug = sanitize_title( str_replace( '/', '_', $path ) );

		$term = $this->insert_term( $path, $this->taxonomy_file, [ 'slug' => $slug ] );

		if ( is_wp_error( $term ) ) {
			$this->logger->stash_error(
				sprintf(
					'Problem creating file tax item "%1$s" for %2$s: %3$s',
					$slug,
					$path,
					$term->get_error_message()
				)
			);

			return;
		}

		// Store file meta for later use
		$this->file_meta = [
			'docblock'  	 => $file->getDocBlock(), // File docblock
			'term_id'   	 => $path, // Term name in the file taxonomy is the file name
			'plugin_version' => $file->getPluginVersion(), // The plugin version
			'deprecated'	 => $this->get_file_deprecation_version( $file ), // Deprecation version
		];

		foreach ( $file->getFunctions() as $function ) {
			$this->import_function( $function, 0, $import_ignored );
		}

		foreach ( $file->getClasses() as $class ) {
			$this->import_class( $class, $import_ignored );
		}

		foreach ( $file->getHooks() as $hook ) {
			$this->import_hook( $hook, 0, $import_ignored );
		}
	}

	/**
	 * Checks if a file is deprecated, and returns the version if so
	 * @param  DocFile  	 		$file The file to check
	 * @return string|bool	The version in which the file was deprecated, or false
	 */
	public function get_file_deprecation_version( $file ) {

		$uses = $file->getUses();

		// Return early if the file doesn't use functions
		if ( ! isset( $uses['functions'] ) || ! isset( $uses['functions'][0] ) ) {
			return false;
		}

		// Check if the first function in this file is _deprecated_function
 		$first_function = $uses['functions'][0];

		if ( $first_function['name'] === '_deprecated_file' ) {
			return $first_function['deprecation_version'];
		}

		return false;
	}

	/**
	 * Create a post for a function.
	 *
	 * @param DocFunction $data           The function data.
	 * @param int   $parent_post_id Optional; post ID of the parent (class or function) this item belongs to. Defaults to zero (no parent).
	 * @param bool  $import_ignored Optional; defaults to false. If true, functions marked `@ignore` will be imported.
	 *
	 * @return void Post ID of this function, false if any failure.
	 */
	public function import_function( DocFunction $data, $parent_post_id = 0, $import_ignored = false ) {
		$function_id = $this->import_item( $data, $parent_post_id, $import_ignored );

		foreach ( $data->getHooks() as $hook ) {
			$this->import_hook( $hook, $function_id, $import_ignored );
		}
	}

	/**
	 * Create a post for a hook
	 *
	 * @param DocHook $data           The hook data.
	 * @param int   $parent_post_id Optional; post ID of the parent (function) this item belongs to. Defaults to zero (no parent).
	 * @param bool  $import_ignored Optional; defaults to false. If true, hooks marked `@ignore` will be imported.
	 *
	 * @return bool|int Post ID of this hook, false if any failure.
	 */
	public function import_hook( DocHook $data, $parent_post_id = 0, $import_ignored = false ) {
		$hook_id = $this->import_item( $data, $parent_post_id, $import_ignored, [ 'post_type' => $this->post_type_hook ] );

		if ( ! $hook_id ) {
			return false;
		}

		update_post_meta( $hook_id, '_wp-parser_hook_type', $data->getType() );

		return $hook_id;
	}

	/**
	 * Create a post for a class
	 *
	 * @param DocClass $data           The class data.
	 * @param bool  $import_ignored Optional; defaults to false. If true, functions marked `@ignore` will be imported.
	 *
	 * @return bool|int Post ID of this function, false if any failure.
	 */
	protected function import_class( DocClass $data, $import_ignored = false ) {
		// Insert this class
		$class_id = $this->import_item( $data, 0, $import_ignored, [ 'post_type' => $this->post_type_class ] );

		if ( ! $class_id ) {
			return false;
		}

		// Set class-specific meta
		update_post_meta( $class_id, '_wp-parser_final', 		(string) $data->isFinal() );
		update_post_meta( $class_id, '_wp-parser_abstract', 	(string) $data->isAbstract() );
		update_post_meta( $class_id, '_wp-parser_extends', 		$data->getExtends() );
		update_post_meta( $class_id, '_wp-parser_implements', 	$data->getImplements() );
		update_post_meta( $class_id, '_wp-parser_properties', 	$data->getProperties() );

		// Now add the methods
		foreach ( $data->getMethods() as $method ) {
			$this->import_method( $data->getName(), $method, $class_id, $import_ignored );
		}

		return $class_id;
	}

	/**
	 * Create a post for a class method.
	 *
	 * @param string $parent           The parent class.
	 * @param DocMethod $data          The method data.
	 * @param int   $parent_post_id Post ID of the parent (class) this method belongs to.
	 * @param bool  $import_ignored Defaults to false. If true, functions marked `@ignore` will be imported.
	 *
	 * @return bool|int Post ID of this function, false if any failure.
	 */
	protected function import_method( string $parent, DocMethod $data, $parent_post_id = 0, $import_ignored = false ) {
		// Namespace method names with the class name
		$data->setName( $parent . '::' . $data->getName() );

		// Insert this method.
		$method_id = $this->import_item( $data, $parent_post_id, $import_ignored, [ 'post_type' => $this->post_type_method ] );

		if ( ! $method_id ) {
			return false;
		}

		// Set method-specific meta.
		update_post_meta( $method_id, '_wp-parser_final', 		$data->isFinal() );
		update_post_meta( $method_id, '_wp-parser_abstract', 	$data->isAbstract() );
		update_post_meta( $method_id, '_wp-parser_static', 		$data->isStatic() );
		update_post_meta( $method_id, '_wp-parser_visibility', 	$data->getVisibility() );

		// Now add the hooks.
		if ( ! empty( $data->getHooks() ) ) {
			foreach ( $data->getHooks() as $hook ) {
				$this->import_hook( $hook, $method_id, $import_ignored );
			}
		}

		return $method_id;
	}

	/**
	 * Formats the namespace.
	 *
	 * @param DocPart $data The docpart to get the namespace from.
	 *
	 * @return string The namespace.
	 */
	private function format_namespace( DocPart $data ) {
		if ( ! method_exists( $data, 'getNamespace' ) ) {
			return $data->getName();
		}

		// Only classes have this?
		$namespace = $data->getNamespace();

		if ( empty( $namespace ) || $namespace === 'global' ) {
			return $data->getName();
		}

		return $namespace . '\\' . $data->getName();
	}

	/**
	 * Gets the slug from the namespace.
	 *
	 * @param string $namespace The namespace to get the slug from.
	 *
	 * @return string The slug.
	 */
	private function get_slug_from_namespace( $namespace ) {
		return sanitize_title( str_replace( '\\', '-', str_replace( '::', '-', $namespace ) ) );
	}

	/**
	 * Gets the ID of the post that exists with the passed name and post type.
	 *
	 * @param string $post_name	The name of the post to search for.
	 * @param string $post_type The post type to search for.
	 *
	 * @return int The post ID.
	 */
	protected function get_existing_item( string $post_name, string $post_type ) {
		$post = get_page_by_title( $post_name, OBJECT, $post_type );

		if ( ! $post ) {
			return 0;
		}

		return (int) $post->ID;
	}

	/**
	 * Create a post for an item (a class or a function).
	 *
	 * Anything that needs to be dealt identically for functions or methods should go in this function.
	 * Anything more specific should go in either import_function() or import_class() as appropriate.
	 *
	 * @param DocPart $data           Data.
	 * @param int   $parent_post_id Optional; post ID of the parent (class or function) this item belongs to. Defaults to zero (no parent).
	 * @param bool  $import_ignored Optional; defaults to false. If true, functions or classes marked `@ignore` will be imported.
	 * @param array $arg_overrides  Optional; array of parameters that override the defaults passed to wp_update_post().
	 *
	 * @return bool|int Post ID of this item, false if any failure.
	 */
	public function import_item( DocPart $data, $parent_post_id = 0, $import_ignored = false, array $arg_overrides = [] ) {
		$is_new_post 		= true;
		$post_needed_update = false;
		$namespace			= $this->format_namespace( $data );
		$slug        		= $this->get_slug_from_namespace( $namespace );

		$doc = $data->getDocblock();

		$post_data = wp_parse_args(
			$arg_overrides,
			[
				'post_content' => $doc['long_description'],
				'post_excerpt' => $doc['description'],
				'post_name'    => $slug,
				'post_parent'  => (int) $parent_post_id,
				'post_status'  => 'publish',
				'post_title'   => $data->getName(),
				'post_type'    => $this->post_type_function,
			]
		);

		// Don't import items marked `@ignore` unless explicitly requested. See https://github.com/WordPress/phpdoc-parser/issues/16
		if ( ! $import_ignored && $data->getIgnored() ) {
			$this->logItem(
				self::IGNORED_ITEM_MESSAGE,
				$post_data['post_type'],
				$namespace,
				( $parent_post_id || $post_data['post_type'] === $this->post_type_method ) ? 2 : 1
			);

			return false;
		}

		if ( $data->getIgnored() ) {
			return false;
		}

		// Look for an existing post for this item
		$existing_post_id = $this->get_existing_item( $post_data['post_title'], $post_data['post_type'] );

		// If duplicate
		if ( ! empty( $existing_post_id ) && $this->has_potential_duplicates( $existing_post_id ) ) {
			$this->updateDuplicate( $existing_post_id, $data );

			return false;
		}

		// Insert/update the item post
		if ( ! empty( $existing_post_id ) ) {
			$is_new_post = false;
			$post_id 	 	 = $existing_post_id;
			$post_data['ID'] = $post_id;

			$post_needed_update = $this->post_needs_update( $post_data, $post_id );

			if ( $post_needed_update ) {
				$post_id = $this->update_post( $post_data );
			}
		}

		// New post
		if ( empty( $existing_post_id ) ) {
			$post_id = $this->insert_post( $post_data );

			// Record the plugin if there is one.
			$this->assign_additional_plugin( $post_id, $this->plugin_name );
			$this->_set_namespaces( $post_id, $data );
		}

		if ( ! isset( $post_id ) || ! $post_id || is_wp_error( $post_id ) ) {
			$this->logErroredItem(
				$post_data['post_type'],
				$namespace,
				( $parent_post_id ) ? 2 : 1
			);

			return false;
		}

		$anything_updated = $this->updateMeta( $data, $post_id, $post_data );

		// If the post didn't need to be updated, but meta or tax changed, update it to bump last modified.
		if ( ! $is_new_post && ! $post_needed_update && array_filter( $anything_updated ) ) {
			wp_update_post( wp_slash( $post_data ), true );
		}

		$this->logParsedItem(
			$is_new_post,
			$post_data['post_type'],
			$namespace,
			( $parent_post_id || $post_data['post_type'] === $this->post_type_method ) ? 2 : 1
		);

		/**
		 * Action at the end of importing an item.
		 *
		 * @param int   $post_id   Optional; post ID of the inserted or updated item.
		 * @param array $data PHPDoc data for the item we just imported
		 * @param array $post_data WordPress data of the post we just inserted or updated
		 */
		do_action( 'wp_parser_import_item', $post_id, $data, $post_data );

		return $post_id;
	}

	/**
	 * Updates a 'duplicate' item (i.e. Yoast SEO and Yoast SEO Premium).
	 *
	 * @param int     $id	The ID of the item that is a duplicate.
	 * @param DocPart $data The data to update some settings with.
	 */
	protected function updateDuplicate( int $id, DocPart $data ) {
		$this->logger->info( 'Skipping ' . $data->getName() . ' as it\'s duplicate' );

		$this->assign_additional_plugin( $id, $this->plugin_name );
		$this->_set_namespaces( $id, $data );
	}

	/**
	 * Inserts a post with the passed post data.
	 *
	 * @param array $post_data The post data to add.
	 *
	 * @return int The newly inserted post ID.
	 */
	private function insert_post( $post_data ) {
		return wp_insert_post( wp_slash( $post_data ), true );
	}

	/**
	 * Updates a post based on the passed post data.
	 *
	 * @param array $post_data The post data to update.
	 *
	 * @return int The post ID of the updated post.
	 */
	private function update_post( $post_data ) {
		return wp_update_post( wp_slash( $post_data ), true );
	}

	/**
	 * Process the Namespace of items and add them to the correct taxonomy terms.
	 *
	 * This creates terms for each of the namespace terms in a hierachical tree
	 * and then adds the item being processed to each of the terms in that tree.
	 *
	 * @param int   $post_id The ID of the post item being processed.
	 * @param DocPart $data	 The data.
	 *
	 * @return void
	 */
	protected function _set_namespaces( $post_id, DocPart $data ) {
		$ns_term  = false;
		$ns_terms = [];

		$namespaces = ( ! empty( $data->getNamespace() ) ) ? explode( '\\', $data->getNamespace() ) : [];

		if ( count( $namespaces ) === 0 ) {
			return;
		}

		foreach ( $namespaces as $namespace ) {
			$ns_term = $this->insert_term( $namespace, $this->taxonomy_namespace, [
					'slug'   => strtolower( str_replace( '_', '-', $namespace ) ),
					'parent' => ( $ns_term ) ? $ns_term['term_id'] : 0,
				]
			);

			if ( is_wp_error( $ns_term ) ) {
				$this->logger->warning( "Cannot set namespace term: " . $ns_term->get_error_message(), 1 );
				$ns_term = false;

				continue;
			}

			$ns_terms[] = (int) $ns_term['term_id'];
		}

		if ( ! empty( $ns_terms ) ) {
			$added_term_relationship = did_action( 'added_term_relationship' );
			wp_set_object_terms( $post_id, $ns_terms, $this->taxonomy_namespace );

			if ( did_action( 'added_term_relationship' ) > $added_term_relationship ) {
				// TODO: Move this.
				$this->anything_updated[] = true;
			}
		}
	}

	/**
	 * Gets the plugin terms associated with the post.
	 *
	 * @param int $post_id The post ID.
	 *
	 * @return array The plugin terms.
	 */
	protected function get_plugin_terms_for_post( $post_id ) {
		return array_map(
			function( $term ) {
				return $term->name;
			},
			wp_get_post_terms( $post_id, $this->taxonomy_plugin )
		);
	}

	/**
	 * Checks if there's a potential duplicate entry, based on the post ID.
	 *
	 * @param int $id The post ID to check.
	 *
	 * @return bool Whether or not there are potential duplicates.
	 */
	protected function has_potential_duplicates( $id ) {
		$associated_terms = $this->get_plugin_terms_for_post( $id );

		if ( empty( $this->plugin_name ) || in_array( $this->plugin_name, $associated_terms, true ) ) {
			return false;
		}

		if ( $this->plugin_name === 'Yoast SEO' ) {
			return in_array( 'Yoast SEO Premium', $associated_terms, true );
		}

		if ( $this->plugin_name === 'Yoast SEO Premium' ) {
			return in_array( 'Yoast SEO', $associated_terms, true );
		}

		return false;
	}

	/**
	 * Determines whether the post needs updating based on the changes found.
	 *
	 * @param array $post_data			The post data from the current item.
	 * @param int   $existing_post_id	The post ID known in the database.
	 *
	 * @return array The difference in data between the current post and the one in the database.
	 */
	protected function post_needs_update( $post_data, $existing_post_id ) {
		return array_diff_assoc( sanitize_post( $post_data, 'db' ), get_post( $existing_post_id, ARRAY_A, 'db' ) );
	}

	/**
	 * Logs error messages related to the insertion or updating of a particular post.
	 *
	 * @param string $type		  The type.
	 * @param string $namespace	  The namespace.
	 * @param int 	 $indentation The amount of indentation to use.
	 *
	 * @return void
	 */
	protected function log_error_message( $type, $namespace, $indentation = 1 ) {
		$this->logger->stash_error( sprintf( self::ERRORED_ITEM_MESSAGE, $type, $namespace ), $indentation );
	}

	/**
	 * Sets the @since versions for the post based on the passed tag data.
	 *
	 * @param int 	$post_id The post ID.
	 * @param array $tags	 The tag data to extract the since data from.
	 *
	 * @return array The set data.
	 */
	protected function set_since_versions( $post_id, $tags ) {
		$since_versions = wp_list_filter( $tags, [ 'name' => 'since' ] );
		$anything_updated = [];

		if ( empty( $since_versions ) ) {
			return $anything_updated;
		}

		// Loop through all @since versions.
		foreach ( $since_versions as $since_version ) {
			if ( empty( $since_version['content'] ) ) {
				continue;
			}

			$since_term = $this->insert_term( $since_version['content'], $this->taxonomy_since_version );

			// Assign the tax item to the post
			if ( is_wp_error( $since_term ) ) {
				$this->logger->warning( "Cannot set @since term: " . $since_term->get_error_message(), 1 );

				continue;
			}

			$added_term_relationship = did_action( 'added_term_relationship' );

			wp_set_object_terms( $post_id, (int) $since_term['term_id'], $this->taxonomy_since_version, true );

			if ( did_action( 'added_term_relationship' ) > $added_term_relationship ) {
				$anything_updated[] = true;
			}
		}

		return $anything_updated;
	}

	/**
	 * Gets the tag's data based on the passed name.
	 *
	 * @param array  $tags The tags data set to extract the data from.
	 * @param string $name The name of the tag to retrieve.
	 *
	 * @return array The tags data. Returns an empty array if none could be found.
	 */
	protected function get_tags_data( array $tags, string $name ) {
		$tag_data = wp_list_filter( $tags, [ 'name' => $name ] );

		if ( empty( $tag_data ) ) {
			$tag_data = wp_list_filter( $this->file_meta['docblock']['tags'], [ 'name' => $name ] );
		}

		return $tag_data;
	}

	/**
	 * Sets the packages for the post based on the passed tag data.
	 *
	 * @param int 	$post_id The post ID.
	 * @param array $tags	 The tag data to extract the package data from.
	 *
	 * @return array The set data.
	 */
	protected function set_packages( $post_id, $tags ) {
		$anything_updated = [];

		$packages = [
			'main' => $this->get_tags_data( $tags, 'package' ),
			'sub'  => $this->get_tags_data( $tags, 'subpackage' ),
		];

		$main_package_id  = false;
		$package_term_ids = [];

		// If the item has any @package/@subpackage markup (or has inherited it from file scope), assign the taxonomy.
		foreach ( $packages as $pack_name => $pack_value ) {
			if ( empty( $pack_value ) ) {
				continue;
			}

			$pack_value = array_shift( $pack_value );
			$pack_value = $pack_value['content'];

			$package_term_args = [ 'parent' => 0 ];

			// Set the parent term_id to look for, as the package taxonomy is hierarchical.
			if ( $pack_name === 'sub' && is_int( $main_package_id ) ) {
				$package_term_args = [ 'parent' => $main_package_id ];
			}

			// If the package doesn't already exist in the taxonomy, add it
			$package_term = $this->insert_term( $pack_value, $this->taxonomy_package, $package_term_args );
			$package_term_ids[] = (int) $package_term['term_id'];

			if ( $pack_name === 'main' && $main_package_id === false && ! is_wp_error( $package_term ) ) {
				$main_package_id = (int) $package_term['term_id'];
			}

			if ( ! is_wp_error( $package_term ) ) {
				continue;
			}

			if ( is_int( $main_package_id ) ) {
				$this->logger->warning( "Cannot create @subpackage term: " . $package_term->get_error_message(), 1 );
			} else {
				$this->logger->warning( "Cannot create @package term: " . $package_term->get_error_message(), 1 );
			}
		}

		$added_term_relationship = did_action( 'added_term_relationship' );
		wp_set_object_terms( $post_id, $package_term_ids, $this->taxonomy_package );

		if ( did_action( 'added_term_relationship' ) > $added_term_relationship ) {
			$anything_updated[] = true;
		}

		return $anything_updated;
	}

	/**
	 * Assign additional plugin taxonomies to the passed post.
	 *
	 * @param int 	 $post_id The post ID.
	 * @param string $plugin  The plugin to assign to the post.
	 *
	 * @return array The term ID's that were set.
	 */
	protected function assign_additional_plugin( $post_id, $plugin ) {
		return wp_set_object_terms( $post_id, $plugin, $this->taxonomy_plugin, true );
	}

	/**
	 * Sets some global settings pre-import.
	 */
	protected function setupImport() {
		do_action( 'wp_parser_starting_import' );

		// Defer term counting for performance
		wp_suspend_cache_invalidation( true );
		wp_defer_term_counting( true );
		wp_defer_comment_counting( true );

		// Remove actions for performance
		remove_action( 'transition_post_status', '_update_blog_date_on_post_publish', 10 );
		remove_action( 'transition_post_status', '__clear_multi_author_cache', 10 );
	}

	/**
	 * Tears down any global settings changed pre-import.
	 */
	protected function teardownImport() {
		/**
		 * Workaround for a WP core bug where hierarchical taxonomy caches are not being cleared
		 *
		 * https://core.trac.wordpress.org/ticket/14485
		 * http://wordpress.stackexchange.com/questions/8357/inserting-terms-in-an-hierarchical-taxonomy
		 */
		delete_option( "{$this->taxonomy_package}_children" );
		delete_option( "{$this->taxonomy_since_version}_children" );

		/**
		 * Action at the end of a complete import
		 */
		do_action( 'wp_parser_ending_import' );

		// Start counting again
		wp_defer_term_counting( false );
		wp_suspend_cache_invalidation( false );
		wp_cache_flush();
		wp_defer_comment_counting( false );
	}

	/**
	 * Logs the inserted or updated item.
	 *
	 * @param bool 	 $is_new_post Whether or not the item is a new post.
	 * @param string $post_type	  The post type of the item that was parsed.
	 * @param string $namespace   The namespace of the item that was parsed.
	 * @param int    $indentation The amount of indentation to apply.
	 */
	protected function logParsedItem( bool $is_new_post, string $post_type, string $namespace, int $indentation = 1 ) {
		if ( $is_new_post ) {
			$this->logItem( self::INSERTED_ITEM_MESSAGE, $post_type, $namespace, $indentation );

			return;
		}

		$this->logItem( self::UPDATED_ITEM_MESSAGE, $post_type, $namespace, $indentation );
	}

	/**
	 * Logs the errored item.
	 *
	 * @param string $post_type	The post type of the item that was skipped.
	 * @param string $namespace The namespace of the item that was skipped.
	 * @param int    $indentation The amount of indentation to apply.
	 */
	protected function logErroredItem( string $post_type, string $namespace, int $indentation = 1 ) {
		switch ( $post_type ) {
			case $this->post_type_class:
				$this->log_error_message( 'class', $namespace );
				break;

			case $this->post_type_method:
				$this->log_error_message( 'method', $namespace, $indentation );
				break;

			case $this->post_type_hook:
				$this->log_error_message( 'hook', $namespace, $indentation );
				break;

			default:
				$this->log_error_message( 'function', $namespace );
		}
	}

	protected function logItem( string $message, string $postType, string $name, int $indentation = 1 ) {
		$postTypeMappings = [
			$this->post_type_class		=> 'class',
			$this->post_type_method 	=> 'method',
			$this->post_type_hook 		=> 'hook',
			$this->post_type_function 	=> 'function',
		];

		if ( ! array_key_exists( $postType, $postTypeMappings ) ) {
			$postType = $this->post_type_function;
		}

		$this->logger->info( sprintf( $message, $postTypeMappings[$postType], $name ), $indentation );
	}

	/**
	 * Updates various meta items.
	 *
	 * @param DocPart 	$data		The data to update the meta with.
	 * @param int     	$post_id	The ID of the item.
	 * @param array 	$post_data	The post data.
	 *
	 * @return array The updated items.
	 */
	protected function updateMeta( DocPart $data, int $post_id, $post_data ): array {
		$anything_updated = [];
		$tags = $data->getTags();

		// If the item has @since markup, assign the taxonomy
		$anything_updated = array_merge( $anything_updated, $this->set_since_versions( $post_id, $tags ) );
		$anything_updated = array_merge( $anything_updated, $this->set_packages( $post_id, $tags ) );

		// Set other taxonomy and post meta to use in the theme templates
		$added_item = did_action( 'added_term_relationship' );
		wp_set_object_terms( $post_id, $this->file_meta['term_id'], $this->taxonomy_file );

		if ( did_action( 'added_term_relationship' ) > $added_item ) {
			$anything_updated[] = true;
		}

		// If the file is deprecated do something
		if ( ! empty( $this->file_meta['deprecated'] ) ) {
			$tags['deprecated'] = $this->file_meta['deprecated'];
		}

		if ( $post_data['post_type'] !== $this->post_type_class ) {
			$anything_updated[] = update_post_meta( $post_id, '_wp-parser_args', $data->getArguments() );
		}

		// If the post type is using namespace aliases, record them.
		if ( ! empty( $data->getAliases() ) ) {
			$anything_updated[] = update_post_meta( $post_id, '_wp_parser_aliases', (array) $data->getAliases() );
		}

		// Record the namespace if there is one.
		if ( ! empty( $data->getNamespace() ) ) {
			$anything_updated[] = update_post_meta( $post_id, '_wp_parser_namespace', (string) addslashes( $data->getNamespace() ) );
		}

		$anything_updated[] = update_post_meta( $post_id, '_wp-parser_line_num', 	 (string) $data->getLine() );
		$anything_updated[] = update_post_meta( $post_id, '_wp-parser_end_line_num', (string) $data->getEndLine() );
		$anything_updated[] = update_post_meta( $post_id, '_wp-parser_tags', $tags );

		return $anything_updated;
}
}
